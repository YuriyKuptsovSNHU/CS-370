### Briefly explain the work that you did on this project: What code were you given? What code did you create yourself?

I implemented the Q-Learning algorithm for the Pirate’s Treasure game. I was given the game’s representation, the code to visual display the game, and the code to create the neural network’s layers. I was also given a basic framework in which to implement the algorithm.

### Connect your learning from throughout this course to the larger field of computer science:

*What do computer scientists do and why does it matter?*

Computer scientists apply their knowledge of computational theory to develop software. A computer scientist may play any or all of several roles in software development: designing software, implementing software, debugging software, optimizing software, and maintaining software. The typical software engineer writes programs using one or more computer programming languages.

Computer scientists have a depth of knowledge about algorithms, data structures, and the mathematics behind the efficiency of both. Computer scientists have enough knowledge about how computer hardware functions to understand the basics of how code, once translated into machine code, is processed by the hardware, but they do not generally know the details about how the computer’s hardware performs these tasks (this is generally the domain of the electrical engineer or “hardware engineer”).

By creating software, computer scientists have an impact on the world around them. They can help people solve problems more quickly through software. Unfortunately, if they do not do their job well, they can cause people frustration and cause a wide range of problems. Computer scientists empower many intellectual endeavors through the software they provide. Their creations have an impact on society, both economic and ethical. Their work can be used to do good or to do harm. A responsible computer scientists avoids doing harm.

*How do I approach a problem as a computer scientist?*

In the most general sense, I gather information about the problem, what the solution to the problem seeks to solve, who the stake holders in the problem are, how do the stakeholders expect to benefit from the solution, and what level of effort does the problem owner expect to expend on finding a solution to the problem. Next, I look for analogous problems. Have analogous problems been solved before? Can I learn anything from these solutions to analogous and similar problems? What are the constraints imposed on the solution to the problem? Must it run on a specific platform? What kind of data does the solution need access to? Where is this data stored?

Once I have gathered a good understanding of the problem, as described above, I confirm that my understanding of the problem and the attributes of the solution match the expectations of the problem’s owner and the stakeholders in the solution. If there is a mismatch, I work to refine the problem description and its constraints, as well as the expectations of the other interested parties, until harmony between all team players is arrived upon.

Next, I consider how the solution will be validated. How will the system be tested? How will we agree that the solution has been met?
After all of this, I begin to design the system. I integrated into the design a testing regime to ensure that each phase of development is kept on track. Development begins. Development consists of a cycle of design, implement, and test. At then end, we seek sign off by the problem owner and the stakeholders, verifying that the system meets their requirements.

*What are my ethical responsibilities to the end user and the organization?*

My ethical responsibilities to the end user include protection of their privacy and efficacy of functionality (my program does what they think it does, both correctly, and not something other than they expect – that is, it is not a trojan). My ethical responsibility to the organization is to be honest, to not compromise their ownership of the software, to not compromise their proprietary knowledge, to write clear and reliable code, and to produce software free of known bugs and errors.

